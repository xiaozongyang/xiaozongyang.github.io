{"meta":{"title":"Xiao Zongyang's Blog","subtitle":"","description":"","author":"Xiao Zongyang","url":"http://xiaozongyang.github.io","root":"/"},"pages":[{"title":"Repositories","date":"2021-03-20T15:25:12.205Z","updated":"2021-03-20T15:25:12.205Z","comments":false,"path":"repository/index.html","permalink":"http://xiaozongyang.github.io/repository/index.html","excerpt":"","text":"github: username: xiaozongyang"}],"posts":[{"title":"arts-20210320","slug":"arts-20210320","date":"2021-03-20T15:25:54.058Z","updated":"2021-03-20T16:06:54.513Z","comments":true,"path":"2021/03/20/arts-20210320/","link":"","permalink":"http://xiaozongyang.github.io/2021/03/20/arts-20210320/","excerpt":"","text":"Algorithm 题目: 优美的排列 分析 优美的排列是一种特殊的排列，需要计算出全排列，然后看某个排列是否符合优美的定义，可以用“回溯“来解决 根据 labuladong 这篇文章给出的回溯算法框架，只需要确定两个动作就可以 选择：将当前遍历的节点加入到路径中，即当某个数字 n 在位置 i 上符合”优美“的定义时，将其加入到选择列表中 取消选择：将当前遍历的节点从选择路径中去掉，进行下一次尝试 解法： 维护以下几个变量进行回溯递归 n 排列长度 selected 数组，保存已经选择的数字 ls 已选择的元素个数 result 保存计数结果 当 ls 长度和 n 相等时，结束递归，返回 count 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public static int countArrangement(int n) &#123; int []selected = new int[n]; int ls = 0; Result result = new Result(); backtrace(selected, ls, n, result); return result.count; &#125; public static void backtrace(int[] selected, int ls, int n, Result result) &#123; if (ls == selected.length) &#123; result.count += 1; return; &#125; for (int j = 1; j &lt;= n; j++) &#123; if (contains(selected, j) || !isPerfect(ls + 1, j)) &#123; continue; &#125; // select selected[ls] = j; backtrace(selected, ls + 1, n, result); // unselect selected[ls] = 0; &#125; &#125; private static boolean contains(int[] selected, int j) &#123; for (int s: selected) &#123; if (s == j) &#123; return true; &#125; &#125; return false; &#125; static boolean isPerfect(int i, int n) &#123; return i % n == 0 || n % i == 0; &#125; public static class Result &#123; public int count = 0; &#125;&#125; 一点优化 motivation 每次回溯时都需要遍历所有的数字，这些数子中部分已经在 selected 数组里了，这部分明显是不符合要求的，因为排列不允许有重复数字 每次判断当前数字是否已经被选过了，需要自己实现一个数组的 contains 方法，时间复杂度为 O(N)，这个操作比较费时 solution 额外维护一个 candidates 数组，来实时维护有哪些元素是备选 额外维护一个 lc 变量，表示数组实际长度 当一个元素从 candidates 中被选走时，将其和数组中最后一个元素交换，并将 lc -1 当回溯结束后，需要取消选择时，再执行一次 swap 操作，原来的元素就被换回来了 代码如下，从 leetcode 的结果来看，耗时从 235ms 减小到 48ms，说明优化有效123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public static int countArrangement(int n) &#123; int []selected = new int[n]; int ls = 0; int []candidates = new int[n]; for (int i = 0; i &lt; n; i++) &#123; candidates[i] = i + 1; &#125; Result result = new Result(); backtrace(1, result, selected, ls, candidates, n); return result.count; &#125; public static void backtrace(int index, Result result, int[] selected, int ls, int[] candidates, int lc) &#123; if (ls == selected.length) &#123; result.count += 1; return; &#125; for (int i = 0; i &lt; lc; i++) &#123; if (isNotPerfect(index, candidates[i])) &#123; continue; &#125; selected[ls] = candidates[i]; swap(candidates, i, lc - 1); backtrace(index + 1, result, selected, ls + 1, candidates, lc - 1); swap(candidates, i, lc - 1); &#125; &#125; private static void swap(int[] candidates, int i, int j) &#123; int tmp = candidates[j]; candidates[j] = candidates[i]; candidates[i] = tmp; &#125; static boolean isNotPerfect(int i, int n) &#123; return i % n != 0 &amp;&amp; n % i != 0; &#125; public static class Result &#123; public int count = 0; &#125;&#125; Review 原文地址： Improving histogram usability for Prometheus and Grafana 本文介绍了 Prometheus 原生的 Histogram 存在的 3 个问题，进而介绍了 VictoriaMetrics 为此所做的努力，以及 Histogram 的几种场景 Prometheus Histogram 的问题 bucket 范围无法很好地适应实际的数据分布，原因在于业务迭代时数据点分布可能会发生变化，会导致需要一直调整 bucket range，难以维护 bucket 数量过多导致时间序列基数过大，导致一系列问题，包括内存占用增长、磁盘占用增长、插入效率降低、查询效率降低 对于同一个 metric，如果两个 TS bucket range 不一致，则这两个 TS 无法进行聚合查询 VictoriaMetrics 的解法 sdk 内置 bucket range 和数量，避免使用者设置的复杂性 只暴露 bucket 中元素不为 0 的 bucket 给 prometheus，从而减少时间序列数量 介绍了将 gauge 用 histogram 函数来计算分布，通过 Grafana Heatmap 来可视化的场景，比如进程内存使用量，来了解组织所有服务内存使用分布情况 Tips Prometheus Blackbox Exporter 适合做拨测，主要原理是提供一个 target 和探测方式，将探测结果生成指标，因此有几个点需要注意 只有 blackbox exporter 没办法直接生成观测工具，需要配合 prometheus 或 vmagent 使用 探测方式和探测地址均由参数指定，需要配合 relabel 配置来保证 label 的正确性 设计系统前，先明确问题的规模、场景，调研后需要做可行性验证 设计目标要能量化，除了明确解决什么问题，明确解决到什么程度也必不可少 Sharetodo","categories":[],"tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://xiaozongyang.github.io/tags/ARTS/"}]},{"title":"arts-20200705","slug":"arts-20200705","date":"2020-07-05T10:56:36.000Z","updated":"2021-03-20T15:27:54.301Z","comments":true,"path":"2020/07/05/arts-20200705/","link":"","permalink":"http://xiaozongyang.github.io/2020/07/05/arts-20200705/","excerpt":"","text":"Algorithm 题目：LeetCode-724 寻找数据的中心索引 分析 根据题目定定义，中心索引 i 左边和右边的元素之和相等，最直接的思路二层循环暴力来算，但是实际上 leftSum(i + 1) = leftSum(i) + nums[i]，其中 leftSum(i) = nums[0] + nums[1] + ... + nums[i - 1] rightSum(i + 1) = rightSum(i + 1) + nums[i]，其中 rightSum(i + 1) = nums[i + 2] + nums[i + 3] + ... + nums[nums.length - 1] 需要注意情况，当 i 左边或右边没有元素时，和为 0 解法 如果 nums.length &lt; 2 则中心索引为 i 先算出 nums[1] 到 nums[nums.length -1] 之和记为初始 rightSum，初始 leftSum 为 0 从下标 1 开始遍历 nums，如果 leftSum 和 rightSum 相等或i == nums.length 时结束，如果 i &lt; nums.lrgnth 返回 i，否则返回 -1 代码123456789101112131415161718192021222324public int pivotIndex(int[] nums) &#123; if (nums.length == 0) &#123; return -1; &#125; if (nums.length == 1) &#123; return 0; &#125; int left = 0; int right = 0; for (int i = 1; i != nums.length; i++) &#123; right += nums[i]; &#125; int i = 1; while (i &lt; nums.length &amp;&amp; left != right) &#123; left += nums[i - 1]; right -= nums[i]; i++; &#125; return left == right ? i - 1 : -1; &#125; Review 原文地址：MapReduce: Simplified Data Processing on Large Clusters Google 经典论文，提出了 MapReduce 编程模型，以及该模型在分布式系统下实现的一些要点和优化 背景：Google 处理大规模的数据需要解决并行化、数据分发、故障处理的问题 解法：提出 MapReduce 的编程模型，隐藏并行、数据分许、故障处理的细节 Map: (k1, v1) -&gt; list(k2, v2) 根据输入的 key/value 对生产新的 key/value 对的集合，作为中间结果，计算逻辑需要用户实现 Reduce: (k2, list(v2)) -&gt; list(v2) 从同一个 key 有序结合中计算得出最终结果，计算逻辑需要用户实现 影响 提出了处理海量数据的通用方案，推动了大数据计算领域发展 简化了并行、故障处理逻辑，提升了研发效果 提供了水平扩展能力，可以通过加机器来提升性能 工程设计 Master Slave 架构：Master 负责监控Woker状态、调度任务 并行策略： 输入文件进行按切分，本质是上做分片，每个分片有对应的 Worker 进行处理 Map 和 Reducer 阶段，Worker 之间没有数据重叠，因此不存在并发问题 故障处理策略：重新执行 执行 Map 任务的 Worker 故障：重新执行该 Worker 的 Map 任务以及相关的 Reduce 任务 执行 Reduce 任务的 Worker 故障：重新执行该 Worker 的 Reduce 任务 优化 本地化：MapReduce 的输入输出为 GFS 分布式文件系统，每个文件存多个副本（通常为3），给 Worker 分配任务时尽量分配给保存输入数据副本的 Worker，不满足条件时，尽量分给靠近持有副本结点的 Worker，降低网络 IO 开销 Backup：当执行任务快结束时，还有某个结点特别慢（可能是机器硬件差或故障等原因）影响整个任务进度，会在其他结点执行一个 Backup 任务，这两个任务任意一个执行完就算执行完成 Tip 以 SDK 的形式提供能力是常见的做法，但是升级会非常头疼，可以考虑把 SDK api 声明暴露给用户，以 javaagent 的方式提供实现可以缓解这个问题，可以在这个方向有些探索 以 javaagent 的方式提供装饰逻辑，来代替 cglib 看起来具有分离、对用户无感知的优点 Share读了《非暴力沟通》前两章，有几个印象比较深的点： 沟通的表达方式很重要，并且是可以后天训练的，有意识的行为比纯本能的行为通常更有效 学会区分观察和评论，不要习惯性采用防御性的姿态，学会区分是客观事实的评价，还是主观个人的评论","categories":[],"tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://xiaozongyang.github.io/tags/ARTS/"}]},{"title":"arts-20200628","slug":"arts-20200628","date":"2020-06-28T16:43:55.000Z","updated":"2021-03-20T15:25:12.204Z","comments":true,"path":"2020/06/29/arts-20200628/","link":"","permalink":"http://xiaozongyang.github.io/2020/06/29/arts-20200628/","excerpt":"","text":"Algorithm比特位计数题目：给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 Sample 1 input: 2 output: [0, 1, 1] Sample 2 input: 5 output: [0, 1, 1, 2, 1, 2]给出 O(n) 一趟遍历的解法 分析： 设计算 n 的 bits 中 1 的个数的过程为 f(n)，则输出为 [f(0), f(1), ..., f(n)]，至少需要遍历一遍 根据题目要求，联想到只有当前的状态可以根据前一步状态来简单计算来得到才能满足要求，看起来是个标准的 dp dp 方程 首先盲猜 n 和 n-1 的关系，简单列举了几个不太有思路 然后想到 int 有移位操作，特别是右移位(&gt;&gt;)时，符号位不变，对于正整数来说减少了一个1，所以有 f(n) = f(n &gt;&gt; 1) + g(n) 其中 g(n)是 n 最低位 1 的个数，我们知道 n 为奇数时 n % 2 == 1, n 为偶数时 n % 2 == 0 n % 2 等价于 n &amp; 1，且后者更快因此 f(n) = f(n &gt;&gt; 1) + (n &amp; 1) 最终代码如下12345678910111213class Solution &#123; public int[] countBits(int num) &#123; int [] bits = new int[num + 1]; if (num == 0) &#123; return bits; &#125; bits[1] = 1; for (int i = 2; i &lt;= num; i++) &#123; bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1); &#125; return bits; &#125;&#125; 看了 disscuss，发现有大佬提到 n &amp; (n - 1) 可以去掉最后一个 1，因此还有一种解法 f(n) = f(n &amp; (n - 1)) + 1 Review Embracing Immutable Architecture https://medium.com/react-weekly/embracing-immutable-architecture-dc04e3f08543 作者认为：状态是软件工程复杂性之源，变化的状态让代码难以理解和维护，不可变状态是控制复杂性的有效手段。 核心要素 严格限制的状态转移，例如只允许 pure function 修改状态 单向数据流 个人理解 和 functional programming 理念类似，状态不可变、只允许新增状态，好处是不共享状态所以不会有并发问题 追求 pure function，会使得函数结果很容易预测，不容易出bug，另外编译器可以提前做优化，性能上有些提升 并非使用所有场景，每次都创建新的状态可能性能开销很大，需要工程师作出权衡 基础架构领域也有这个趋势，例如部署方式上 Docker 和 tomcat war 包的区别，前者每次部署都使用新 image，而后者是在同一个 web container 做原地升级 Tip 关于 kotlin 的实践 kotlin 和 java 混写 不能使用 lombok 原因 根据官方的说法，kotlin 和 java 混写时，需要 kotlin 在 java 之前被编译see https://kotlinlang.org/docs/reference/using-maven.html lombok 是编译时注解，Getter, Setter, Constructor 等根据注解生成的方法都需要编译成字节码之后才有 解决办法 把 带lombok 注解的 java 代码用插件 Delombok 编译插件配置 需要为 kotlin-maven-plugin 指定 java 和 kotlin 源代码路径，e.g.1234567891011121314151617181920&lt;plugin&gt; &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt; &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;kotlin.version&#125;&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;compile&lt;/id&gt; &lt;phase&gt;compile&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;sourceDirs&gt; &lt;sourceDir&gt;$&#123;project.basedir&#125;/src/main/kotlin&lt;/sourceDir&gt; &lt;sourceDir&gt;$&#123;project.basedir&#125;/src/main/java&lt;/sourceDir&gt; &lt;/sourceDirs&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;execution&lt;/plugin&gt; 打包指定 Main Class 原因：在 java 项目打包时，通常需要指定 Main Class 作为项目的入口，而在纯 kotlin 代码中，main 函数通常是下面这种写法1234567// Foo.kt// empty classclass Foo &#123;&#125;fun main(args: Array&lt;String&gt;) &#123; // do something&#125; 看了下编译结果，编译生成的类为 FooKt.class，在 pom 里写上就ok了Sharebenchmark 是工程是进行性能分析的必备工具，jmh 作为 openjdk 生态中的重要工具，广泛应用在各大开源项目中，本文简单介绍下 jmh 的 HelloWorld，作为工程师快速上手 jmh 的小参考, see openjdk tools - Hello jmh","categories":[],"tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://xiaozongyang.github.io/tags/ARTS/"}]},{"title":"hello-jmh","slug":"hello-jmh","date":"2020-06-28T16:43:31.000Z","updated":"2021-03-20T15:25:12.204Z","comments":true,"path":"2020/06/29/hello-jmh/","link":"","permalink":"http://xiaozongyang.github.io/2020/06/29/hello-jmh/","excerpt":"","text":"Hello Jmh 本文将介绍如何使用 jmh 工具做简单的 benchmark 主要步骤 在项目中引入依赖 编写 benchmark 方法 配置 pom 构建并启动 benchmark 引入依赖 在 maven 中添加如下依赖 123456789&lt;properties&gt; &lt;jmh.version&gt;1.23&lt;/jmh.version&gt;&lt;/properties&gt;&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt; &lt;artifactId&gt;jmh-core&lt;/artifactId&gt; &lt;version&gt;$&#123;jmh.version&#125;&lt;/version&gt;&lt;/dependency&gt; 编写 benchmark 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package io.xiaozyimport org.openjdk.jmh.annotations.Benchmarkimport org.openjdk.jmh.annotations.BenchmarkModeimport org.openjdk.jmh.annotations.Forkimport org.openjdk.jmh.annotations.Measurementimport org.openjdk.jmh.annotations.Modeimport org.openjdk.jmh.annotations.OutputTimeUnitimport org.openjdk.jmh.annotations.Scopeimport org.openjdk.jmh.annotations.Stateimport org.openjdk.jmh.annotations.Threadsimport org.openjdk.jmh.annotations.Warmupimport java.util.*import java.util.concurrent.TimeUnit/** * @author xiaozy01 * @date 2020-06-18 */@State(Scope.Benchmark)@OutputTimeUnit(TimeUnit.SECONDS)@BenchmarkMode(Mode.Throughput)open class SlaveReaderBenachmark &#123; companion object &#123; private const val ITERATION_COUNT = 10 private const val WARMUP_COUNT = 10 private const val THREAD_COUNT = 4 private const val FORK_COUNT = 4 &#125; var singleDb: JdbcTemplate = createSingleDb() var connectionClusterDb: JdbcTemplate = createConnectionClusterDb() var datasourceClusterDb: JdbcTemplate = createDataSourceClusterDb() @Benchmark @Fork(value = FORK_COUNT) @Threads(value = THREAD_COUNT) @Warmup(iterations = WARMUP_COUNT) @Measurement(iterations = ITERATION_COUNT) fun concate(): String &#123; return \"a\" + \" \" +\"b\"; &#125; @Benchmark @Fork(value = FORK_COUNT) @Threads(value = THREAD_COUNT) @Warmup(iterations = WARMUP_COUNT) @Measurement(iterations = ITERATION_COUNT) fun format(): String &#123; return java.lang.String.format(\"%s %s\", \"a\", \"b\") &#125;&#125; 配置 pom 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155&lt;build&gt; &lt;plugins&gt; &lt;!-- 1. Compile Kotlin sources first. --&gt; &lt;plugin&gt; &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt; &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt; &lt;!-- Put an approriate Kotlin compiler version here. --&gt; &lt;version&gt;$&#123;kotlin.version&#125;&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;process-sources&lt;/id&gt; &lt;phase&gt;generate-sources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;sourceDirs&gt; &lt;sourceDir&gt;$&#123;project.basedir&#125;/src/main/kotlin&lt;/sourceDir&gt; &lt;/sourceDirs&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;process-test-sources&lt;/id&gt; &lt;phase&gt;test-compile&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;test-compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- 2. Invoke JMH generators to produce benchmark code --&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;process-sources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;java&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;includePluginDependencies&gt;true&lt;/includePluginDependencies&gt; &lt;mainClass&gt;org.openjdk.jmh.generators.bytecode.JmhBytecodeGenerator&lt;/mainClass&gt; &lt;arguments&gt; &lt;argument&gt;$&#123;project.basedir&#125;/target/classes/&lt;/argument&gt; &lt;argument&gt;$&#123;project.basedir&#125;/target/generated-sources/jmh/&lt;/argument&gt; &lt;argument&gt;$&#123;project.basedir&#125;/target/classes/&lt;/argument&gt; &lt;argument&gt;$&#123;jmh.generator&#125;&lt;/argument&gt; &lt;/arguments&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt; &lt;artifactId&gt;jmh-generator-bytecode&lt;/artifactId&gt; &lt;version&gt;$&#123;jmh.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;!-- 3. Add JMH generated code to the compile session. --&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;add-source&lt;/id&gt; &lt;phase&gt;process-sources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;add-source&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;sources&gt; &lt;source&gt;$&#123;project.basedir&#125;/target/generated-sources/jmh&lt;/source&gt; &lt;/sources&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- 4. Compile JMH generated code. --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;configuration&gt; &lt;compilerVersion&gt;$&#123;javac.target&#125;&lt;/compilerVersion&gt; &lt;source&gt;$&#123;javac.target&#125;&lt;/source&gt; &lt;target&gt;$&#123;javac.target&#125;&lt;/target&gt; &lt;compilerArgument&gt;-proc:none&lt;/compilerArgument&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 5. Package all the dependencies into the JAR --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;-benchmark&lt;/finalName&gt; &lt;transformers&gt; &lt;transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\"&gt; &lt;mainClass&gt;org.openjdk.jmh.Main&lt;/mainClass&gt; &lt;/transformer&gt; &lt;transformer implementation=\"org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\"/&gt; &lt;/transformers&gt; &lt;filters&gt; &lt;filter&gt; &lt;!-- Shading signed JARs will fail without this. http://stackoverflow.com/questions/999489/invalid-signature-file-when-attempting-to-run-a-jar --&gt; &lt;artifact&gt;*:*&lt;/artifact&gt; &lt;excludes&gt; &lt;exclude&gt;META-INF/*.SF&lt;/exclude&gt; &lt;exclude&gt;META-INF/*.DSA&lt;/exclude&gt; &lt;exclude&gt;META-INF/*.RSA&lt;/exclude&gt; &lt;/excludes&gt; &lt;/filter&gt; &lt;/filters&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 构建并启动 构建 mvn package 启动 java -jar ${project.artifactId}-benchmark.jar，${project.artifactId} 为 benchmark 所在module name References https://openjdk.java.net/projects/code-tools/jmh","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://xiaozongyang.github.io/tags/java/"},{"name":"jmh","slug":"jmh","permalink":"http://xiaozongyang.github.io/tags/jmh/"},{"name":"benchmark","slug":"benchmark","permalink":"http://xiaozongyang.github.io/tags/benchmark/"},{"name":"kotlin","slug":"kotlin","permalink":"http://xiaozongyang.github.io/tags/kotlin/"}]}],"categories":[],"tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://xiaozongyang.github.io/tags/ARTS/"},{"name":"java","slug":"java","permalink":"http://xiaozongyang.github.io/tags/java/"},{"name":"jmh","slug":"jmh","permalink":"http://xiaozongyang.github.io/tags/jmh/"},{"name":"benchmark","slug":"benchmark","permalink":"http://xiaozongyang.github.io/tags/benchmark/"},{"name":"kotlin","slug":"kotlin","permalink":"http://xiaozongyang.github.io/tags/kotlin/"}]}